<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="serializedSessions">
      <map>
        <entry key="d5ba5dcd-abcc-40ff-b0f8-9aa471c4ac50" value="{&quot;id&quot;:&quot;d5ba5dcd-abcc-40ff-b0f8-9aa471c4ac50&quot;,&quot;name&quot;:&quot;[TextContent(type\u003dtext, text\u003d\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:circular-progress-image/src/main/java/com/paraooo/circular_progress_image/CircularProgressImage.kt, lines\u003dALL(1-257)\npackage com.paraooo.circular_progress_image\n\nimport androidx.compose.animation.core.Animatable\nimport androidx.compose.animation.core.AnimationSpec\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.Stable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.geometry.Rect\nimport androidx.compose.ui.geometry.Size\nimport androidx.compose.ui.graphics.BlendMode\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.graphics.Outline\nimport androidx.compose.ui.graphics.Path\nimport androidx.compose.ui.graphics.PathOperation\nimport androidx.compose.ui.graphics.Shape\nimport androidx.compose.ui.graphics.painter.Painter\nimport androidx.compose.ui.layout.ContentScale\nimport androidx.compose.ui.unit.Density\nimport androidx.compose.ui.unit.LayoutDirection\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.launch\nimport kotlin.math.abs\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.tan\n\n// 모든 주석들을 영어로 작성해줘 !!\n\n/**\n * AnimatedCircularProgressImage :\n * @param initialProgress 초기 진행률 (0.0f ~ 1.0f)\n * @param coroutineScope 애니메이션을 실행할 코루틴 스코프\n */\n@Stable\nclass CircularProgressState(\n    initialProgress: Float,\n    private val coroutineScope: CoroutineScope\n) {\n    private val _progress \u003d Animatable(initialProgress.coerceIn(0f, 1f))\n    val progress: Float\n        get() \u003d _progress.value\n\n    /**\n     * 지정된 목표 진행률까지 애니메이션을 실행합니다.\n     * @param targetProgress 목표 진행률 (0.0f ~ 1.0f)\n     * @param animationSpec 사용할 애니메이션 스펙\n     */\n    fun moveTo(\n        targetProgress: Float,\n        animationSpec: AnimationSpec\u003cFloat\u003e \u003d tween(durationMillis \u003d 1000)\n    ) {\n        coroutineScope.launch {\n            _progress.animateTo(\n                targetValue \u003d targetProgress.coerceIn(0f, 1f),\n                animationSpec \u003d animationSpec\n            )\n        }\n    }\n}\n\n/**\n * AnimatedCircularProgressImage와 함께 사용할 CircularProgressState를 생성하고 기억합니다.\n * @param initialProgress 초기 진행률\n */\n@Composable\nfun rememberCircularProgressState(\n    initialProgress: Float \u003d 0f\n): CircularProgressState {\n    val coroutineScope \u003d rememberCoroutineScope()\n    return remember(coroutineScope) {\n        CircularProgressState(\n            initialProgress \u003d initialProgress,\n            coroutineScope \u003d coroutineScope\n        )\n    }\n}\n\n@Composable\nfun AnimatedCircularProgressImage(\n    state: CircularProgressState,\n    painter: Painter,\n    modifier: Modifier \u003d Modifier,\n    startAngle: Float \u003d 0f,\n    maxSweepAngle: Float \u003d 360f,\n    color : Color? \u003d null,\n    backgroundColor : Color? \u003d null\n) {\n    CircularProgressImage(\n        painter \u003d painter,\n        progress \u003d state.progress,\n        modifier \u003d modifier,\n        startAngle \u003d startAngle,\n        maxSweepAngle \u003d maxSweepAngle,\n        color \u003d color,\n        backgroundColor \u003d backgroundColor\n    )\n}\n\n@Composable\nfun CircularProgressImage(\n    painter: Painter,\n    progress: Float,\n    modifier: Modifier \u003d Modifier,\n    startAngle: Float \u003d 0f,\n    maxSweepAngle: Float \u003d 360f,\n    color : Color? \u003d null,\n    backgroundColor : Color? \u003d null\n) {\n    Box(\n        contentAlignment \u003d Alignment.Center,\n        modifier \u003d modifier\n    ){\n        if (backgroundColor !\u003d null) {\n            Image(\n                modifier \u003d Modifier.matchParentSize(),\n                painter \u003d painter,\n                contentDescription \u003d null,\n                colorFilter \u003d ColorFilter.tint(backgroundColor, BlendMode.SrcIn),\n                contentScale \u003d ContentScale.Crop\n            )\n        }\n\n        Image(\n            painter \u003d painter,\n            contentDescription \u003d null,\n            modifier \u003d modifier.matchParentSize().clip(\n                BorderSegmentShape(\n                    startAngleDegrees \u003d startAngle,\n                    sweepAngleDegrees \u003d maxSweepAngle * progress.coerceIn(0f, 1f)\n                )\n            ),\n            colorFilter \u003d if (color !\u003d null) ColorFilter.tint(color, BlendMode.SrcIn) else null,\n            contentScale \u003d ContentScale.Crop\n        )\n    }\n\n}\n\n/**\n * [최종 수정] 로직을 두 경우로 나누어 모든 엣지 케이스를 해결한 최종 버전\n */\nclass BorderSegmentShape(\n    private val startAngleDegrees: Float,\n    private val sweepAngleDegrees: Float\n) : Shape {\n\n    override fun createOutline(\n        size: Size,\n        layoutDirection: LayoutDirection,\n        density: Density\n    ): Outline {\n        val path: Path\n\n        if (sweepAngleDegrees \u003c\u003d 180f) {\n            path \u003d createConvexSegmentPath(size, startAngleDegrees, sweepAngleDegrees)\n        } else {\n            val fullRectPath \u003d Path().apply { addRect(Rect(Offset.Zero, size)) }\n\n            val emptyStartAngle \u003d startAngleDegrees + sweepAngleDegrees\n            val emptySweepAngle \u003d 360f - sweepAngleDegrees\n            val emptyPath \u003d createConvexSegmentPath(size, emptyStartAngle, emptySweepAngle)\n\n            path \u003d Path().apply {\n                op(fullRectPath, emptyPath, PathOperation.Difference)\n            }\n        }\n        return Outline.Generic(path)\n    }\n\n    /**\n     * 항상 볼록(convex)한 180도 이하의 조각 경로를 생성하는\n     *\n     *\n     *\n     *\n     * 함수\n     */\n    private fun createConvexSegmentPath(size: Size, startAngle: Float, sweepAngle: Float): Path {\n        return Path().apply {\n            if (abs(sweepAngle) \u003c 0.01f) return@apply\n\n            val center \u003d Offset(size.width / 2f, size.height / 2f)\n            val endAngle \u003d startAngle + sweepAngle\n\n            val startPoint \u003d calculateIntersection(size, startAngle)\n            val endPoint \u003d calculateIntersection(size, endAngle)\n\n            moveTo(center.x, center.y)\n            lineTo(startPoint.x, startPoint.y)\n\n            val corners \u003d listOf(\n                Offset(size.width, 0f),     // 0: Top-Right\n                Offset(size.width, size.height), // 1: Bottom-Right\n                Offset(0f, size.height),    // 2: Bottom-Left\n                Offset(0f, 0f)         // 3: Top-Left\n            )\n\n            val startSide \u003d getSide(size, startPoint)\n            val endSide \u003d getSide(size, endPoint)\n\n            var currentSide \u003d startSide\n            while(currentSide !\u003d endSide) {\n                lineTo(corners[currentSide].x, corners[currentSide].y)\n                currentSide \u003d (currentSide + 1) % 4\n            }\n\n            lineTo(endPoint.x, endPoint.y)\n            close()\n        }\n    }\n\n    private fun getSide(size: Size, point: Offset): Int {\n        val tolerance \u003d 0.001f\n        return when {\n            abs(point.y) \u003c tolerance -\u003e 0 // Top\n            abs(point.x - size.width) \u003c tolerance -\u003e 1 // Right\n            abs(point.y - size.height) \u003c tolerance -\u003e 2 // Bottom\n            else -\u003e 3 // Left\n        }\n    }\n\n    private fun calculateIntersection(size: Size, angleFromTop: Float): Offset {\n        val normalizedAngle \u003d (angleFromTop % 360 + 360) % 360\n        val centerX \u003d size.width / 2f\n        val centerY \u003d size.height / 2f\n        when (normalizedAngle) {\n            0f, 360f -\u003e return Offset(centerX, 0f)\n            90f -\u003e return Offset(size.width, centerY)\n            180f -\u003e return Offset(centerX, size.height)\n            270f -\u003e return Offset(0f, centerY)\n        }\n        val angleRad \u003d Math.toRadians(-normalizedAngle + 90.0).toFloat()\n        val tanAngle \u003d tan(angleRad)\n        val x \u003d size.width / 2f\n        val y \u003d x * tanAngle\n        return if (abs(y) \u003c\u003d size.height / 2f) {\n            if (cos(angleRad) \u003e 0) Offset(size.width, centerY - y) else Offset(0f, centerY + y)\n        } else {\n            val invTanAngle \u003d 1 / tanAngle\n            val y2 \u003d size.height / 2f\n            val x2 \u003d y2 * invTanAngle\n            if (sin(angleRad) \u003e 0) Offset(centerX + x2, 0f) else Offset(centerX - x2, size.height)\n        }\n    }\n}\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n기존 주석들을 전부 지우고 \nKdoc 형식으로 주석을 작성해줘 전부 영어로\n\u003c/user_query\u003e)]&quot;,&quot;timestamp&quot;:1754457337119,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:circular-progress-image/src/main/java/com/paraooo/circular_progress_image/CircularProgressImage.kt, lines\u003dALL(1-257)\npackage com.paraooo.circular_progress_image\n\nimport androidx.compose.animation.core.Animatable\nimport androidx.compose.animation.core.AnimationSpec\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.Stable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.geometry.Rect\nimport androidx.compose.ui.geometry.Size\nimport androidx.compose.ui.graphics.BlendMode\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.graphics.Outline\nimport androidx.compose.ui.graphics.Path\nimport androidx.compose.ui.graphics.PathOperation\nimport androidx.compose.ui.graphics.Shape\nimport androidx.compose.ui.graphics.painter.Painter\nimport androidx.compose.ui.layout.ContentScale\nimport androidx.compose.ui.unit.Density\nimport androidx.compose.ui.unit.LayoutDirection\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.launch\nimport kotlin.math.abs\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.tan\n\n// 모든 주석들을 영어로 작성해줘 !!\n\n/**\n * AnimatedCircularProgressImage :\n * @param initialProgress 초기 진행률 (0.0f ~ 1.0f)\n * @param coroutineScope 애니메이션을 실행할 코루틴 스코프\n */\n@Stable\nclass CircularProgressState(\n    initialProgress: Float,\n    private val coroutineScope: CoroutineScope\n) {\n    private val _progress \u003d Animatable(initialProgress.coerceIn(0f, 1f))\n    val progress: Float\n        get() \u003d _progress.value\n\n    /**\n     * 지정된 목표 진행률까지 애니메이션을 실행합니다.\n     * @param targetProgress 목표 진행률 (0.0f ~ 1.0f)\n     * @param animationSpec 사용할 애니메이션 스펙\n     */\n    fun moveTo(\n        targetProgress: Float,\n        animationSpec: AnimationSpec\u003cFloat\u003e \u003d tween(durationMillis \u003d 1000)\n    ) {\n        coroutineScope.launch {\n            _progress.animateTo(\n                targetValue \u003d targetProgress.coerceIn(0f, 1f),\n                animationSpec \u003d animationSpec\n            )\n        }\n    }\n}\n\n/**\n * AnimatedCircularProgressImage와 함께 사용할 CircularProgressState를 생성하고 기억합니다.\n * @param initialProgress 초기 진행률\n */\n@Composable\nfun rememberCircularProgressState(\n    initialProgress: Float \u003d 0f\n): CircularProgressState {\n    val coroutineScope \u003d rememberCoroutineScope()\n    return remember(coroutineScope) {\n        CircularProgressState(\n            initialProgress \u003d initialProgress,\n            coroutineScope \u003d coroutineScope\n        )\n    }\n}\n\n@Composable\nfun AnimatedCircularProgressImage(\n    state: CircularProgressState,\n    painter: Painter,\n    modifier: Modifier \u003d Modifier,\n    startAngle: Float \u003d 0f,\n    maxSweepAngle: Float \u003d 360f,\n    color : Color? \u003d null,\n    backgroundColor : Color? \u003d null\n) {\n    CircularProgressImage(\n        painter \u003d painter,\n        progress \u003d state.progress,\n        modifier \u003d modifier,\n        startAngle \u003d startAngle,\n        maxSweepAngle \u003d maxSweepAngle,\n        color \u003d color,\n        backgroundColor \u003d backgroundColor\n    )\n}\n\n@Composable\nfun CircularProgressImage(\n    painter: Painter,\n    progress: Float,\n    modifier: Modifier \u003d Modifier,\n    startAngle: Float \u003d 0f,\n    maxSweepAngle: Float \u003d 360f,\n    color : Color? \u003d null,\n    backgroundColor : Color? \u003d null\n) {\n    Box(\n        contentAlignment \u003d Alignment.Center,\n        modifier \u003d modifier\n    ){\n        if (backgroundColor !\u003d null) {\n            Image(\n                modifier \u003d Modifier.matchParentSize(),\n                painter \u003d painter,\n                contentDescription \u003d null,\n                colorFilter \u003d ColorFilter.tint(backgroundColor, BlendMode.SrcIn),\n                contentScale \u003d ContentScale.Crop\n            )\n        }\n\n        Image(\n            painter \u003d painter,\n            contentDescription \u003d null,\n            modifier \u003d modifier.matchParentSize().clip(\n                BorderSegmentShape(\n                    startAngleDegrees \u003d startAngle,\n                    sweepAngleDegrees \u003d maxSweepAngle * progress.coerceIn(0f, 1f)\n                )\n            ),\n            colorFilter \u003d if (color !\u003d null) ColorFilter.tint(color, BlendMode.SrcIn) else null,\n            contentScale \u003d ContentScale.Crop\n        )\n    }\n\n}\n\n/**\n * [최종 수정] 로직을 두 경우로 나누어 모든 엣지 케이스를 해결한 최종 버전\n */\nclass BorderSegmentShape(\n    private val startAngleDegrees: Float,\n    private val sweepAngleDegrees: Float\n) : Shape {\n\n    override fun createOutline(\n        size: Size,\n        layoutDirection: LayoutDirection,\n        density: Density\n    ): Outline {\n        val path: Path\n\n        if (sweepAngleDegrees \u003c\u003d 180f) {\n            path \u003d createConvexSegmentPath(size, startAngleDegrees, sweepAngleDegrees)\n        } else {\n            val fullRectPath \u003d Path().apply { addRect(Rect(Offset.Zero, size)) }\n\n            val emptyStartAngle \u003d startAngleDegrees + sweepAngleDegrees\n            val emptySweepAngle \u003d 360f - sweepAngleDegrees\n            val emptyPath \u003d createConvexSegmentPath(size, emptyStartAngle, emptySweepAngle)\n\n            path \u003d Path().apply {\n                op(fullRectPath, emptyPath, PathOperation.Difference)\n            }\n        }\n        return Outline.Generic(path)\n    }\n\n    /**\n     * 항상 볼록(convex)한 180도 이하의 조각 경로를 생성하는\n     *\n     *\n     *\n     *\n     * 함수\n     */\n    private fun createConvexSegmentPath(size: Size, startAngle: Float, sweepAngle: Float): Path {\n        return Path().apply {\n            if (abs(sweepAngle) \u003c 0.01f) return@apply\n\n            val center \u003d Offset(size.width / 2f, size.height / 2f)\n            val endAngle \u003d startAngle + sweepAngle\n\n            val startPoint \u003d calculateIntersection(size, startAngle)\n            val endPoint \u003d calculateIntersection(size, endAngle)\n\n            moveTo(center.x, center.y)\n            lineTo(startPoint.x, startPoint.y)\n\n            val corners \u003d listOf(\n                Offset(size.width, 0f),     // 0: Top-Right\n                Offset(size.width, size.height), // 1: Bottom-Right\n                Offset(0f, size.height),    // 2: Bottom-Left\n                Offset(0f, 0f)         // 3: Top-Left\n            )\n\n            val startSide \u003d getSide(size, startPoint)\n            val endSide \u003d getSide(size, endPoint)\n\n            var currentSide \u003d startSide\n            while(currentSide !\u003d endSide) {\n                lineTo(corners[currentSide].x, corners[currentSide].y)\n                currentSide \u003d (currentSide + 1) % 4\n            }\n\n            lineTo(endPoint.x, endPoint.y)\n            close()\n        }\n    }\n\n    private fun getSide(size: Size, point: Offset): Int {\n        val tolerance \u003d 0.001f\n        return when {\n            abs(point.y) \u003c tolerance -\u003e 0 // Top\n            abs(point.x - size.width) \u003c tolerance -\u003e 1 // Right\n            abs(point.y - size.height) \u003c tolerance -\u003e 2 // Bottom\n            else -\u003e 3 // Left\n        }\n    }\n\n    private fun calculateIntersection(size: Size, angleFromTop: Float): Offset {\n        val normalizedAngle \u003d (angleFromTop % 360 + 360) % 360\n        val centerX \u003d size.width / 2f\n        val centerY \u003d size.height / 2f\n        when (normalizedAngle) {\n            0f, 360f -\u003e return Offset(centerX, 0f)\n            90f -\u003e return Offset(size.width, centerY)\n            180f -\u003e return Offset(centerX, size.height)\n            270f -\u003e return Offset(0f, centerY)\n        }\n        val angleRad \u003d Math.toRadians(-normalizedAngle + 90.0).toFloat()\n        val tanAngle \u003d tan(angleRad)\n        val x \u003d size.width / 2f\n        val y \u003d x * tanAngle\n        return if (abs(y) \u003c\u003d size.height / 2f) {\n            if (cos(angleRad) \u003e 0) Offset(size.width, centerY - y) else Offset(0f, centerY + y)\n        } else {\n            val invTanAngle \u003d 1 / tanAngle\n            val y2 \u003d size.height / 2f\n            val x2 \u003d y2 * invTanAngle\n            if (sin(angleRad) \u003e 0) Offset(centerX + x2, 0f) else Offset(centerX - x2, size.height)\n        }\n    }\n}\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n기존 주석들을 전부 지우고 \nKdoc 형식으로 주석을 작성해줘 전부 영어로\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[]}]}" />
        <entry key="fad8ef9f-65a7-4e6f-a4a9-b5fe9fa1c8e2" value="{&quot;id&quot;:&quot;fad8ef9f-65a7-4e6f-a4a9-b5fe9fa1c8e2&quot;,&quot;name&quot;:&quot;[TextContent(type\u003dtext, text\u003d\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:circular-progress-image/src/main/java/com/paraooo/circular_progress_image/CircularProgressImage.kt, lines\u003dALL(1-257)\npackage com.paraooo.circular_progress_image\n\nimport androidx.compose.animation.core.Animatable\nimport androidx.compose.animation.core.AnimationSpec\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.Stable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.geometry.Rect\nimport androidx.compose.ui.geometry.Size\nimport androidx.compose.ui.graphics.BlendMode\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.graphics.Outline\nimport androidx.compose.ui.graphics.Path\nimport androidx.compose.ui.graphics.PathOperation\nimport androidx.compose.ui.graphics.Shape\nimport androidx.compose.ui.graphics.painter.Painter\nimport androidx.compose.ui.layout.ContentScale\nimport androidx.compose.ui.unit.Density\nimport androidx.compose.ui.unit.LayoutDirection\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.launch\nimport kotlin.math.abs\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.tan\n\n// 모든 주석들을 영어로 작성해줘 !!\n\n/**\n * AnimatedCircularProgressImage :\n * @param initialProgress 초기 진행률 (0.0f ~ 1.0f)\n * @param coroutineScope 애니메이션을 실행할 코루틴 스코프\n */\n@Stable\nclass CircularProgressState(\n    initialProgress: Float,\n    private val coroutineScope: CoroutineScope\n) {\n    private val _progress \u003d Animatable(initialProgress.coerceIn(0f, 1f))\n    val progress: Float\n        get() \u003d _progress.value\n\n    /**\n     * 지정된 목표 진행률까지 애니메이션을 실행합니다.\n     * @param targetProgress 목표 진행률 (0.0f ~ 1.0f)\n     * @param animationSpec 사용할 애니메이션 스펙\n     */\n    fun moveTo(\n        targetProgress: Float,\n        animationSpec: AnimationSpec\u003cFloat\u003e \u003d tween(durationMillis \u003d 1000)\n    ) {\n        coroutineScope.launch {\n            _progress.animateTo(\n                targetValue \u003d targetProgress.coerceIn(0f, 1f),\n                animationSpec \u003d animationSpec\n            )\n        }\n    }\n}\n\n/**\n * AnimatedCircularProgressImage와 함께 사용할 CircularProgressState를 생성하고 기억합니다.\n * @param initialProgress 초기 진행률\n */\n@Composable\nfun rememberCircularProgressState(\n    initialProgress: Float \u003d 0f\n): CircularProgressState {\n    val coroutineScope \u003d rememberCoroutineScope()\n    return remember(coroutineScope) {\n        CircularProgressState(\n            initialProgress \u003d initialProgress,\n            coroutineScope \u003d coroutineScope\n        )\n    }\n}\n\n@Composable\nfun AnimatedCircularProgressImage(\n    state: CircularProgressState,\n    painter: Painter,\n    modifier: Modifier \u003d Modifier,\n    startAngle: Float \u003d 0f,\n    maxSweepAngle: Float \u003d 360f,\n    color : Color? \u003d null,\n    backgroundColor : Color? \u003d null\n) {\n    CircularProgressImage(\n        painter \u003d painter,\n        progress \u003d state.progress,\n        modifier \u003d modifier,\n        startAngle \u003d startAngle,\n        maxSweepAngle \u003d maxSweepAngle,\n        color \u003d color,\n        backgroundColor \u003d backgroundColor\n    )\n}\n\n@Composable\nfun CircularProgressImage(\n    painter: Painter,\n    progress: Float,\n    modifier: Modifier \u003d Modifier,\n    startAngle: Float \u003d 0f,\n    maxSweepAngle: Float \u003d 360f,\n    color : Color? \u003d null,\n    backgroundColor : Color? \u003d null\n) {\n    Box(\n        contentAlignment \u003d Alignment.Center,\n        modifier \u003d modifier\n    ){\n        if (backgroundColor !\u003d null) {\n            Image(\n                modifier \u003d Modifier.matchParentSize(),\n                painter \u003d painter,\n                contentDescription \u003d null,\n                colorFilter \u003d ColorFilter.tint(backgroundColor, BlendMode.SrcIn),\n                contentScale \u003d ContentScale.Crop\n            )\n        }\n\n        Image(\n            painter \u003d painter,\n            contentDescription \u003d null,\n            modifier \u003d modifier.matchParentSize().clip(\n                BorderSegmentShape(\n                    startAngleDegrees \u003d startAngle,\n                    sweepAngleDegrees \u003d maxSweepAngle * progress.coerceIn(0f, 1f)\n                )\n            ),\n            colorFilter \u003d if (color !\u003d null) ColorFilter.tint(color, BlendMode.SrcIn) else null,\n            contentScale \u003d ContentScale.Crop\n        )\n    }\n\n}\n\n/**\n * [최종 수정] 로직을 두 경우로 나누어 모든 엣지 케이스를 해결한 최종 버전\n */\nclass BorderSegmentShape(\n    private val startAngleDegrees: Float,\n    private val sweepAngleDegrees: Float\n) : Shape {\n\n    override fun createOutline(\n        size: Size,\n        layoutDirection: LayoutDirection,\n        density: Density\n    ): Outline {\n        val path: Path\n\n        if (sweepAngleDegrees \u003c\u003d 180f) {\n            path \u003d createConvexSegmentPath(size, startAngleDegrees, sweepAngleDegrees)\n        } else {\n            val fullRectPath \u003d Path().apply { addRect(Rect(Offset.Zero, size)) }\n\n            val emptyStartAngle \u003d startAngleDegrees + sweepAngleDegrees\n            val emptySweepAngle \u003d 360f - sweepAngleDegrees\n            val emptyPath \u003d createConvexSegmentPath(size, emptyStartAngle, emptySweepAngle)\n\n            path \u003d Path().apply {\n                op(fullRectPath, emptyPath, PathOperation.Difference)\n            }\n        }\n        return Outline.Generic(path)\n    }\n\n    /**\n     * 항상 볼록(convex)한 180도 이하의 조각 경로를 생성하는\n     *\n     *\n     *\n     *\n     * 함수\n     */\n    private fun createConvexSegmentPath(size: Size, startAngle: Float, sweepAngle: Float): Path {\n        return Path().apply {\n            if (abs(sweepAngle) \u003c 0.01f) return@apply\n\n            val center \u003d Offset(size.width / 2f, size.height / 2f)\n            val endAngle \u003d startAngle + sweepAngle\n\n            val startPoint \u003d calculateIntersection(size, startAngle)\n            val endPoint \u003d calculateIntersection(size, endAngle)\n\n            moveTo(center.x, center.y)\n            lineTo(startPoint.x, startPoint.y)\n\n            val corners \u003d listOf(\n                Offset(size.width, 0f),     // 0: Top-Right\n                Offset(size.width, size.height), // 1: Bottom-Right\n                Offset(0f, size.height),    // 2: Bottom-Left\n                Offset(0f, 0f)         // 3: Top-Left\n            )\n\n            val startSide \u003d getSide(size, startPoint)\n            val endSide \u003d getSide(size, endPoint)\n\n            var currentSide \u003d startSide\n            while(currentSide !\u003d endSide) {\n                lineTo(corners[currentSide].x, corners[currentSide].y)\n                currentSide \u003d (currentSide + 1) % 4\n            }\n\n            lineTo(endPoint.x, endPoint.y)\n            close()\n        }\n    }\n\n    private fun getSide(size: Size, point: Offset): Int {\n        val tolerance \u003d 0.001f\n        return when {\n            abs(point.y) \u003c tolerance -\u003e 0 // Top\n            abs(point.x - size.width) \u003c tolerance -\u003e 1 // Right\n            abs(point.y - size.height) \u003c tolerance -\u003e 2 // Bottom\n            else -\u003e 3 // Left\n        }\n    }\n\n    private fun calculateIntersection(size: Size, angleFromTop: Float): Offset {\n        val normalizedAngle \u003d (angleFromTop % 360 + 360) % 360\n        val centerX \u003d size.width / 2f\n        val centerY \u003d size.height / 2f\n        when (normalizedAngle) {\n            0f, 360f -\u003e return Offset(centerX, 0f)\n            90f -\u003e return Offset(size.width, centerY)\n            180f -\u003e return Offset(centerX, size.height)\n            270f -\u003e return Offset(0f, centerY)\n        }\n        val angleRad \u003d Math.toRadians(-normalizedAngle + 90.0).toFloat()\n        val tanAngle \u003d tan(angleRad)\n        val x \u003d size.width / 2f\n        val y \u003d x * tanAngle\n        return if (abs(y) \u003c\u003d size.height / 2f) {\n            if (cos(angleRad) \u003e 0) Offset(size.width, centerY - y) else Offset(0f, centerY + y)\n        } else {\n            val invTanAngle \u003d 1 / tanAngle\n            val y2 \u003d size.height / 2f\n            val x2 \u003d y2 * invTanAngle\n            if (sin(angleRad) \u003e 0) Offset(centerX + x2, 0f) else Offset(centerX - x2, size.height)\n        }\n    }\n}\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n기존 주석들을 전부 지우고 \nKdoc 형식으로 주석을 작성해줘 전부 영어로\n\u003c/user_query\u003e)]&quot;,&quot;timestamp&quot;:1754457309007,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:circular-progress-image/src/main/java/com/paraooo/circular_progress_image/CircularProgressImage.kt, lines\u003dALL(1-257)\npackage com.paraooo.circular_progress_image\n\nimport androidx.compose.animation.core.Animatable\nimport androidx.compose.animation.core.AnimationSpec\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.Stable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.geometry.Rect\nimport androidx.compose.ui.geometry.Size\nimport androidx.compose.ui.graphics.BlendMode\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.graphics.Outline\nimport androidx.compose.ui.graphics.Path\nimport androidx.compose.ui.graphics.PathOperation\nimport androidx.compose.ui.graphics.Shape\nimport androidx.compose.ui.graphics.painter.Painter\nimport androidx.compose.ui.layout.ContentScale\nimport androidx.compose.ui.unit.Density\nimport androidx.compose.ui.unit.LayoutDirection\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.launch\nimport kotlin.math.abs\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.tan\n\n// 모든 주석들을 영어로 작성해줘 !!\n\n/**\n * AnimatedCircularProgressImage :\n * @param initialProgress 초기 진행률 (0.0f ~ 1.0f)\n * @param coroutineScope 애니메이션을 실행할 코루틴 스코프\n */\n@Stable\nclass CircularProgressState(\n    initialProgress: Float,\n    private val coroutineScope: CoroutineScope\n) {\n    private val _progress \u003d Animatable(initialProgress.coerceIn(0f, 1f))\n    val progress: Float\n        get() \u003d _progress.value\n\n    /**\n     * 지정된 목표 진행률까지 애니메이션을 실행합니다.\n     * @param targetProgress 목표 진행률 (0.0f ~ 1.0f)\n     * @param animationSpec 사용할 애니메이션 스펙\n     */\n    fun moveTo(\n        targetProgress: Float,\n        animationSpec: AnimationSpec\u003cFloat\u003e \u003d tween(durationMillis \u003d 1000)\n    ) {\n        coroutineScope.launch {\n            _progress.animateTo(\n                targetValue \u003d targetProgress.coerceIn(0f, 1f),\n                animationSpec \u003d animationSpec\n            )\n        }\n    }\n}\n\n/**\n * AnimatedCircularProgressImage와 함께 사용할 CircularProgressState를 생성하고 기억합니다.\n * @param initialProgress 초기 진행률\n */\n@Composable\nfun rememberCircularProgressState(\n    initialProgress: Float \u003d 0f\n): CircularProgressState {\n    val coroutineScope \u003d rememberCoroutineScope()\n    return remember(coroutineScope) {\n        CircularProgressState(\n            initialProgress \u003d initialProgress,\n            coroutineScope \u003d coroutineScope\n        )\n    }\n}\n\n@Composable\nfun AnimatedCircularProgressImage(\n    state: CircularProgressState,\n    painter: Painter,\n    modifier: Modifier \u003d Modifier,\n    startAngle: Float \u003d 0f,\n    maxSweepAngle: Float \u003d 360f,\n    color : Color? \u003d null,\n    backgroundColor : Color? \u003d null\n) {\n    CircularProgressImage(\n        painter \u003d painter,\n        progress \u003d state.progress,\n        modifier \u003d modifier,\n        startAngle \u003d startAngle,\n        maxSweepAngle \u003d maxSweepAngle,\n        color \u003d color,\n        backgroundColor \u003d backgroundColor\n    )\n}\n\n@Composable\nfun CircularProgressImage(\n    painter: Painter,\n    progress: Float,\n    modifier: Modifier \u003d Modifier,\n    startAngle: Float \u003d 0f,\n    maxSweepAngle: Float \u003d 360f,\n    color : Color? \u003d null,\n    backgroundColor : Color? \u003d null\n) {\n    Box(\n        contentAlignment \u003d Alignment.Center,\n        modifier \u003d modifier\n    ){\n        if (backgroundColor !\u003d null) {\n            Image(\n                modifier \u003d Modifier.matchParentSize(),\n                painter \u003d painter,\n                contentDescription \u003d null,\n                colorFilter \u003d ColorFilter.tint(backgroundColor, BlendMode.SrcIn),\n                contentScale \u003d ContentScale.Crop\n            )\n        }\n\n        Image(\n            painter \u003d painter,\n            contentDescription \u003d null,\n            modifier \u003d modifier.matchParentSize().clip(\n                BorderSegmentShape(\n                    startAngleDegrees \u003d startAngle,\n                    sweepAngleDegrees \u003d maxSweepAngle * progress.coerceIn(0f, 1f)\n                )\n            ),\n            colorFilter \u003d if (color !\u003d null) ColorFilter.tint(color, BlendMode.SrcIn) else null,\n            contentScale \u003d ContentScale.Crop\n        )\n    }\n\n}\n\n/**\n * [최종 수정] 로직을 두 경우로 나누어 모든 엣지 케이스를 해결한 최종 버전\n */\nclass BorderSegmentShape(\n    private val startAngleDegrees: Float,\n    private val sweepAngleDegrees: Float\n) : Shape {\n\n    override fun createOutline(\n        size: Size,\n        layoutDirection: LayoutDirection,\n        density: Density\n    ): Outline {\n        val path: Path\n\n        if (sweepAngleDegrees \u003c\u003d 180f) {\n            path \u003d createConvexSegmentPath(size, startAngleDegrees, sweepAngleDegrees)\n        } else {\n            val fullRectPath \u003d Path().apply { addRect(Rect(Offset.Zero, size)) }\n\n            val emptyStartAngle \u003d startAngleDegrees + sweepAngleDegrees\n            val emptySweepAngle \u003d 360f - sweepAngleDegrees\n            val emptyPath \u003d createConvexSegmentPath(size, emptyStartAngle, emptySweepAngle)\n\n            path \u003d Path().apply {\n                op(fullRectPath, emptyPath, PathOperation.Difference)\n            }\n        }\n        return Outline.Generic(path)\n    }\n\n    /**\n     * 항상 볼록(convex)한 180도 이하의 조각 경로를 생성하는\n     *\n     *\n     *\n     *\n     * 함수\n     */\n    private fun createConvexSegmentPath(size: Size, startAngle: Float, sweepAngle: Float): Path {\n        return Path().apply {\n            if (abs(sweepAngle) \u003c 0.01f) return@apply\n\n            val center \u003d Offset(size.width / 2f, size.height / 2f)\n            val endAngle \u003d startAngle + sweepAngle\n\n            val startPoint \u003d calculateIntersection(size, startAngle)\n            val endPoint \u003d calculateIntersection(size, endAngle)\n\n            moveTo(center.x, center.y)\n            lineTo(startPoint.x, startPoint.y)\n\n            val corners \u003d listOf(\n                Offset(size.width, 0f),     // 0: Top-Right\n                Offset(size.width, size.height), // 1: Bottom-Right\n                Offset(0f, size.height),    // 2: Bottom-Left\n                Offset(0f, 0f)         // 3: Top-Left\n            )\n\n            val startSide \u003d getSide(size, startPoint)\n            val endSide \u003d getSide(size, endPoint)\n\n            var currentSide \u003d startSide\n            while(currentSide !\u003d endSide) {\n                lineTo(corners[currentSide].x, corners[currentSide].y)\n                currentSide \u003d (currentSide + 1) % 4\n            }\n\n            lineTo(endPoint.x, endPoint.y)\n            close()\n        }\n    }\n\n    private fun getSide(size: Size, point: Offset): Int {\n        val tolerance \u003d 0.001f\n        return when {\n            abs(point.y) \u003c tolerance -\u003e 0 // Top\n            abs(point.x - size.width) \u003c tolerance -\u003e 1 // Right\n            abs(point.y - size.height) \u003c tolerance -\u003e 2 // Bottom\n            else -\u003e 3 // Left\n        }\n    }\n\n    private fun calculateIntersection(size: Size, angleFromTop: Float): Offset {\n        val normalizedAngle \u003d (angleFromTop % 360 + 360) % 360\n        val centerX \u003d size.width / 2f\n        val centerY \u003d size.height / 2f\n        when (normalizedAngle) {\n            0f, 360f -\u003e return Offset(centerX, 0f)\n            90f -\u003e return Offset(size.width, centerY)\n            180f -\u003e return Offset(centerX, size.height)\n            270f -\u003e return Offset(0f, centerY)\n        }\n        val angleRad \u003d Math.toRadians(-normalizedAngle + 90.0).toFloat()\n        val tanAngle \u003d tan(angleRad)\n        val x \u003d size.width / 2f\n        val y \u003d x * tanAngle\n        return if (abs(y) \u003c\u003d size.height / 2f) {\n            if (cos(angleRad) \u003e 0) Offset(size.width, centerY - y) else Offset(0f, centerY + y)\n        } else {\n            val invTanAngle \u003d 1 / tanAngle\n            val y2 \u003d size.height / 2f\n            val x2 \u003d y2 * invTanAngle\n            if (sin(angleRad) \u003e 0) Offset(centerX + x2, 0f) else Offset(centerX - x2, size.height)\n        }\n    }\n}\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n기존 주석들을 전부 지우고 \nKdoc 형식으로 주석을 작성해줘 전부 영어로\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[]}]}" />
      </map>
    </option>
  </component>
</project>